\documentclass[aspectratio=169,pdf,hyperref={unicode},14pt]{beamer}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian,english]{babel}
\usepackage{listings}
\usepackage{color}
\usepackage{default}
\usepackage{hyperref}

% Настройки бимера
\usetheme{Copenhagen}

% Настройки листинга
\definecolor{comments}{rgb}{0.5,0.5,0.5}
\definecolor{stdtypes}{rgb}{0.3,0.0,0.0}

\lstdefinestyle{cppcode}{
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  frame=L,
  xleftmargin=\parindent,
  language=C++,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  morekeywords={constexpr,static_assert,decltype,co_await,co_return},
  keywordstyle=\bfseries\color{blue},
  commentstyle=\itshape\color{comments},
  stringstyle=\color{brown},
  classoffset=1,
  morekeywords=[1]{std,map,launch,future,shared_future,promise,packaged_task,async,move,to_string,when_any_result,when_any,tuple,when_all,list,vector,cout,flush},
  keywordstyle=[1]\bfseries\color{stdtypes},
}

\newcommand{\gooditem}[1]{\setbeamercolor{local structure}{fg=green}\item #1}
\newcommand{\baditem}[1]{\setbeamercolor{local structure}{fg=red}\item #1}
\newcommand{\isodoc}[1]{{\scriptsize \color{gray} #1}}

\title{Нестандартный future/promise}
\author{Сергей Видюк}
\date{15 февраля 2019}

\begin{document}

\begin{frame}
 \maketitle
\end{frame}

\begin{frame}[t]{Кратко обо мне}
 \begin{itemize}[<+->]
  \item Работаю в команде 3D карыт мобильной верси 2ГИС
  \item На последних трёх проектах был недоволен самописными API передачи данных между асинхронными задачами
  \item Написал свою реализацию \texttt{future/promise} API на базе Concurrency~TS \url{https://github.com/VestniK/portable_concurrency}
 \end{itemize}
\end{frame}

\begin{frame}[t]{Давайте напишем прогу которая...}
 \begin{itemize}[<+->]
  \item Рисует карту на базе web-тайлов
  \item Отображает большое количество маркеров разных приоритетов
  \item Выполняет разные задачи на разных потоках
  \item Не использует мутексов
  \item Не зависает и не падает на выходе
  \item Лежит на гитхабе: \url{https://github.com/VestniK/mapex}
 \end{itemize}
\end{frame}

\begin{frame}[fragile,t]{\texttt{future} в UI потоке}
\begin{onlyenv}<1>
{\em Q:} Когда мы хотим запускать асинронные задачи?

{\em A:} Кода нам нельзя блокировать текущий поток.

{\em Q:} Что мы можем сделать с \texttt{future} на результат асинхронной задачи?

{\em A:} Заблокироваться чтобы получить результат.
\end{onlyenv}
\begin{onlyenv}<2->
 \begin{itemize}
  \item<2-> Есть задачи по загрузке тайлов
  \item<3-> Есть загруженные тайлы
  \item<4-> Перед отрисовкой хотим забирать готовые тайлы без блокировок
 \end{itemize}
\begin{onlyenv}<2>
 \begin{lstlisting}[style=cppcode]
struct tile_id {
  int tx;
  int ty;
  int z_level;
};

map<tile_id, future<QImage>> tasks;
 \end{lstlisting}
\end{onlyenv}
\begin{onlyenv}<3>
 \begin{lstlisting}[style=cppcode]
map<tile_id, future<QImage>> tasks;
map<tile_id, QImage> tiles;
 \end{lstlisting}
\end{onlyenv}
\begin{onlyenv}<4>
 \begin{lstlisting}[style=cppcode]
map<tile_id, future<QImage>> tasks;
map<tile_id, QImage> tiles;

for (auto [id, task]: tasks) {
  if (task.is_ready())
    tiles[id] = task.get();
}
 \end{lstlisting}
\end{onlyenv}
\end{onlyenv}
\end{frame}

\begin{frame}[fragile,t]{Загружаем тайлы}
 \begin{onlyenv}<1>
  \begin{lstlisting}[style=cppcode]
QImage load_tile(tile_id id);
  \end{lstlisting}
  \begin{itemize}
   \item Пусть синхронная функция загрузки у нас уже есть
  \end{itemize}
  \end{onlyenv}
  \begin{onlyenv}<2-3>
  \begin{lstlisting}[style=cppcode]
map<tile_id, std::future<QImage>> tasks;
...
tasks[id] = std::async(
  launch::async,
  [id] {return load_tile(id);}
);
  \end{lstlisting}
  \begin{itemize}
   \begin{onlyenv}<2>
    \item Воспользуемся \texttt{std::async}
   \end{onlyenv}
   \begin{onlyenv}<3>
    \baditem Удаление задач только через ожидание их завершения
    \baditem На выходе ждём завершения всех текущих задач
   \end{onlyenv}
  \end{itemize}
  \end{onlyenv}
  \begin{onlyenv}<4>
  \begin{lstlisting}[style=cppcode]
map<tile_id, pc::future<QImage>> tasks;
...
tasks[id] = pc::async(
  QThreadPool::globalInstance(),
  [id] {return load_tile(id);}
);
  \end{lstlisting}
  \begin{itemize}
   \item Перейдём на \texttt{pc::async}
  \end{itemize}
  \end{onlyenv}
\end{frame}

\begin{frame}[fragile,t]{Executors}
 \begin{itemize}
  \item<1-> Откуда \texttt{pc::async} знает про \texttt{QThreadPool}?
  \item<3> Так же расскажем ему про \texttt{QObject}
 \end{itemize}
 \begin{onlyenv}<2>
  \begin{lstlisting}[style=cppcode]
namespace portable_concurrency {
template <>
struct is_executor<QThreadPool*>: std::true_type {};
} // namespace portable_concurrency

// ADL
void post(
  QThreadPool* pool,
  pc::unique_function<void()> task
);
  \end{lstlisting}
 \end{onlyenv}
 \begin{onlyenv}<3>
  \begin{lstlisting}[style=cppcode]
namespace portable_concurrency {
template <>
struct is_executor<QObject*>: std::true_type {};
} // namespace portable_concurrency

// ADL
void post(
  QObject* pool,
  pc::unique_function<void()> task
);
  \end{lstlisting}
 \end{onlyenv}
\end{frame}

\begin{frame}[fragile,t]{Сетевые запросы и \texttt{promise}}
 \begin{itemize}[<+->]
  \item Мы хотим работать с Qt сетью через \texttt{future}
  \item Но она асинхронно работает через сигналы
  \item На помощь приходит \texttt{promise}
 \end{itemize}
 \begin{onlyenv}<-2>
 \begin{lstlisting}[style=cppcode]
future<QNetworkReply*> send_requiest(
  QNetworkAccessManager, QUrl
);
 \end{lstlisting}
 \end{onlyenv}
 \begin{onlyenv}<3>
  \begin{lstlisting}[style=cppcode]
class promised_reply: QObject {
  promise<QNetworkReply*> p_;
  void on_reply_finished() {
    p_.set_value(sender());
  }
  void on_reply_error() {
    p_.set_error(sender()->error());
  }
};
  \end{lstlisting}
 \end{onlyenv}
\end{frame}

\begin{frame}[fragile,t]{\texttt{future<future<future<T>{}>{}>}}
 \begin{itemize}[<+->]
  \item Звать \texttt{send\_request} можно только в сетевом потоке
  \item Какой тип вернёт нам \texttt{async}?
  \item \texttt{future<future<T>{}>} сворачивается в \texttt{future<T>}
 \end{itemize}
 \begin{onlyenv}<2>
 \begin{lstlisting}[style=cppcode]
QNetworkAccessManager nm;
auto f = async(
  &nm, [&nm] {return send_request(nm, url);}
);
 \end{lstlisting}
 \end{onlyenv}
 \begin{onlyenv}<3>
 \begin{lstlisting}[style=cppcode]
QNetworkAccessManager nm;
future<QNetworkReply*> f = async(
  &nm, [&nm] {return send_request(nm, url);}
);
 \end{lstlisting}
 \end{onlyenv}
\end{frame}

\begin{frame}[fragile,t]{Цепочки задач}
 \begin{onlyenv}<1>
 \begin{lstlisting}[style=cppcode]
QUrl get_tile_url(tile_id);
QImage parse_image(QIODevice*);

tasks[id] = async(&nm,
  [&nm, id] { return send_reques(nm, get_tile_url(id)); }
);
 \end{lstlisting}
 \end{onlyenv}
 \begin{onlyenv}<2>
 \begin{lstlisting}[style=cppcode]
QUrl get_tile_url(tile_id);
QImage parse_image(QIODevice*);

tasks[id] = async(&nm,
  [&nm, id] { return send_reques(nm, get_tile_url(id)); }
).next(QThreadPool::globalInstance(),
  [](QNetworkReply* reply) { return parse_image(reply); }
);
 \end{lstlisting}
 \end{onlyenv}
 \begin{onlyenv}<3>
 \begin{lstlisting}[style=cppcode]
QUrl get_tile_url(tile_id);
QImage parse_image(QIODevice*);

tasks[id] = async(&nm,
  [&nm, id] { return send_reques(nm, get_tile_url(id)); }
).next(QThreadPool::globalInstance(),
  [](QNetworkReply* reply) { return parse_image(reply); }
).then(this,
  [this](future<QImage> f) { update(); return f; }
);
 \end{lstlisting}
 \end{onlyenv}
\end{frame}

\begin{frame}[fragile,t]{Отмена задач}
 \begin{itemize}[<+->]
  \item Нужен ли \texttt{parse\_image} для уже невидимых тайлов?
  \item А может нужно прервать саму из загрузку?
  \item А что делать с очень долго выполняющимися задачами?
 \end{itemize}
 \begin{onlyenv}<2>
 \begin{lstlisting}[style=cppcode]
QNetworkReply* reply = nm.get(url);
promise<QNetworkReply*> p{
  canceller_arg, [reply] {reply->abort();}
};
 \end{lstlisting}
 \end{onlyenv}
 \begin{onlyenv}<3>
 \begin{lstlisting}[style=cppcode]
future<T> f;
future<R> res = f.then([](promise<R> p, future<T> f) {
  not_too_long_op1();
  if (!p.is_awaiten()) return;
  not_too_long_op2();
});
 \end{lstlisting}
 \end{onlyenv}
\end{frame}

\begin{frame}{Параллельная генерализация POI}
 ?
\end{frame}

\begin{frame}{Загружаем POI}
 ?
\end{frame}

\begin{frame}{Спасибо за внимание}
\centerline{\includegraphics[height=4.5cm]{question_mark_blue.png}}
\end{frame}

\end{document}
